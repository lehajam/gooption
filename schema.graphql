interface ReferenceIndex {
	symbol: String! @id @search(by: [hash])
	quotes: [Quote] @hasInverse(field: refIndex)
	contracts: [Contract] @hasInverse(field: refIndex)
}

interface Quote {
	symbol: String! @id @search(by: [hash])
	datePublished: DateTime! @search(by: [hour])
	refIndex: ReferenceIndex!
	source: String!
	last: Float!
	bid: Float
	ask: Float
	low: Float
	high: Float
	open: Float
	close: Float
	volume: Float
}

interface Contract {
	refIndex: [ReferenceIndex]
	currency: Currency!
	trades: [Trade] @hasInverse(field: contract)
}

interface ValuationResult {
	id: ID!
	trade: Trade
	datePublished: DateTime! @search(by: [hour])
	value: Float!
	source: String! @search(by: [hash])
}

type Currency implements ReferenceIndex {
	onshore: String! @search(by: [hash])
	offshore: String! @search(by: [hash])
}

type Option implements Contract {
	strike: Float!
	putcall: String!
	expiry: DateTime! @search
	optionType: String! @search
}

type Price implements ValuationResult {
	_: Boolean
}

type Delta implements ValuationResult {
	_: Boolean
}

type Gamma implements ValuationResult {
	_: Boolean
}

type Theta implements ValuationResult {
	_: Boolean
}

type PnL implements ValuationResult {
	actual: Float!
	expected: Float!
	residual: Float!
}

type Trade {
	id: ID!
	tradeDate: DateTime! @search
	quantity: Float!
	contract: Contract!
	trader: Trader!
	book: Book
	valuations: [ValuationResult] @hasInverse(field: trade)
}

type Book {
	name: String! @search(by: [hash])  @id
	trades: [Trade] @hasInverse(field: book)
	traders: [Trader]
}

interface User {
	name: String! @search(by: [hash])  @id
}

type Trader implements User {
	books: [Book] @hasInverse(field: traders)
	trades: [Trade] @hasInverse(field: trader)
	office: Office
}

type Office {
	name: String! @search(by: [hash])  @id
	traders: [Trader] @hasInverse(field: office)
}
